<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[传统工业升级中的IT技术]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%B7%A5%E4%B8%9A4.0%E4%B8%AD%E7%9A%84IT%2F</url>
    <content type="text"><![CDATA[听了吴晓波的有关传统工业向智能化方向的节目，感觉很有触动，吴从汉诺威工业展的近几年的展台内容变化，洞悉未来工业发展的方向是必然是智能化和互相协作，而要达成这个目标就必须要依托于先进的IT技术，包括 cloud技术，负责设备的联网，接入，数据的收集，作为IoT的的I端存在，同时，高级的系统往往比较复杂，由各种组件构成，cloud端作为大脑中枢，负责协调部件之间的沟通交互，所以还要有一套安全，可靠的消息传递系统 基于大数据的挖掘技术，对收集来的数据，做分类，新业务模型的探测、故障模式的识别等 人工智能技术，行为的自适应，当然，这个是比较high level了，一般的工业设备还用不上，除非要造出来能模拟人类自主意识的工业机器人 这个过程应该会有点漫长，至少分三个阶段 第一阶段，传统工业设备，传感器，接入IoT云端。这个过程赋予这些设备生命力，从此不再是一个个信息孤岛，像一个个老黄牛向埋头苦干，cloud会来倾听它们发出的声音，同时这些数据被移动、PC端的application重新的组合定义规则，展示出来因为互联网相关的技术都是现成，个人感觉，这个过程5~10年就差不多成熟稳定了，当前正处在这个阶段 第二阶段，大数据挖掘。现在很多的公司都在研究这个东西，可是真正对得起其付出的产品和应用却寥寥无几，基本上还在跟风状态。一方面是大数据技术方兴未艾，还在不断的发展中，只停留在纯技术层面，结合领域的应用比较匮乏，另一方面，对于这个大数据究竟能用做什么，怎么做，能实现什么商业价值，如何变现到企业的利润，普遍没有很好的想法，就好比互网联刚开始的时候，没有什么明确的盈利模式，直到yahoo找到卖广告这条路后才确定这是个大金矿。所以，现在能做的事情，也只是把第一个阶段的数据拿过来，做一个大数据的框架，放在那里，然后慢慢思考，研究怎么用好这些数据，提供哪些增值服务客户会买单。 第三阶段，智能化。这个比较超前，暂时没有很好的想法，可能未来的有这个么一个场景：基于你的消费习惯，智能算法会提取你的性格特征，行为模式，抽象出一个你在cyber空间里的虚拟形象，并预测你可能喜欢的产品和款式等，然后在你想要刚好有某个需求而没有现有产品满足要求的时候，直接雪中送炭地推送给你它的预测，并支持高度的定制，从选材的等级，到功能的自定义，印刷的logo，到包装配送一律可以自由选择，提交订单后，被无人工厂的自动订单系统接单，需求会系统自动分解成制造逻辑，分发给各个制造子系统并开启生产。 目前看的最清楚的是第一个阶段，这个阶段，对IoT架构师的需求是非常大的，尤其是既懂一定硬件开发知识，同时又对互联网高性能，可用和扩展精通的人第二个阶段，从目前看，可能更多是提供数据服务，比如从cloud框架导出数据到大数据框架，再由后者提供多维度的数据分解，分析，报表的功能]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>工业4.0</tag>
        <tag>制造业转型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh免密码登录和传输]]></title>
    <url>%2F2017%2F05%2F19%2Fssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%92%8C%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[Why玩linux的，都会遇到需要操作一大堆serve时，要切换不同身份，端口和密码去分别登录，烦人的很，其实ssh提供了一种基于非对称加密的方法实现免密码登录 How假定需要从A传输文件或登录到B，执行以下步骤 Step 1在A机器上生成的ssh public-private keys，如果已经生成过了，可忽略这一步1ssh-keygen -t rsa 就会在~/.ssh/目录下生成一个id_rsa (private key) and id_ras.pub (public key) Step 2在A机器上配置~/.ssh/config文件,add below content12345Host fire HostName 115.159.114.116 Port 22 User ubuntu IdentityFile ~/.ssh/id_rsa Note: ‘Port’ field default to 22, ‘User’ default to the current account name on machine A ‘IdentityFile’ is the private key you want to user on machine A, aka the private key file you generated in step 1 Please modify them if necessary Step 3在机器B上，添加机器A的public key的完成内容到 ~/.ssh/authorized_keys，create the file if not not exist可以添加多个哦 添加完成后，就可以在A上免密ssh到B了 ssh fire scp ./xxx fire:~/ ReferenceSimplify Your Life With an SSH Config File]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>tool</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang中对象方法作为函数指针]]></title>
    <url>%2F2017%2F05%2F19%2Fgolang%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[裸函数作为指针不是什么新鲜事，其它的语言也是可以的，golang当然也可以，譬如12345type FT func(int)func Fa(int)&#123;&#125;func Test(FT)&#123;&#125;Test(Fa) //pass function as parameter 但是像下面这样，对象实例的方法是否可以作为函数参数传递呢？12345678type A struct &#123; // ...&#125;func (a *A) Foo(bar, baz int) &#123;&#125;b := new(A)foob := b.Foo // foob is of type func(int, int) 答案是肯定的，而且很智能：当特定对象实例的method作为函数指针时传递时，接受者会保证在调用的时候，调用到是这个对象实例的method，method的任何操作都会针对该对象实例生效，而且不需要传任何类似于this、self指针之类的东西 换句话说，对象实例+method 作为绑定的整体传递给接受者的 通过以下代码可以验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( "fmt")type Outer struct&#123; a string&#125;func (o *Outer)Hello(in *Inner)&#123; fmt.Println("Inner:",in,"\tcall\tOuter:",o.a)&#125;type Inner struct&#123; a string cb Cb&#125;type Cb func(*Inner)func (in *Inner)Register(cb Cb)&#123; in.cb = cb&#125;func (in *Inner)Say()&#123; in.cb(in)&#125;func main() &#123; out1 := Outer&#123;a:"out1 instance"&#125; out2 := Outer&#123;a:"out2 instance"&#125; fmt.Println("out1 :",&amp;out1) fmt.Println("out2 :",&amp;out2) in1 := Inner&#123;a:"int1 instance"&#125; in1.Register(out1.Hello) in1.Say() in1.Register(out2.Hello) in1.Say() &#125; 执行起来输出如下结果1234out1 : &amp;&#123;out1 instance&#125;out2 : &amp;&#123;out2 instance&#125;Inner: &amp;&#123;int1 instance 0xc6be0&#125; call Outer: out1 instanceInner: &amp;&#123;int1 instance 0xc6be0&#125; call Outer: out2 instance 参考文章https://groups.google.com/forum/#!topic/golang-nuts/t1r6px7yGIYhttps://github.com/golang/go/issues/2280]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>golang</tag>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存架构]]></title>
    <url>%2F2017%2F05%2F19%2F%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Basic knowlege of memory arch why to solve the mismatch of cpu and memory speed, avoid cpu hungry to decrease the frequency memory access from cpu, and access cpu cache if that have to happen do every effort to avoid missing hit of cpu cache whatSMP（UMA）一致性内存架构，早期的架构，多个CPU共享使用一块物理内存，总线硬件负责协调各CPU对内存的访问，所以对各个CPU来说，看到的内存数据是一致的，所以才叫做Uniform Memory Access MPP针对SMP share one memory的缺点，设计分布式存储器模式，every cpu have their own individual memory, called a node, all the node are full connected as one system, the consistency among nodes is guaranted by software not hardware(bus)。每个CPU只能访问自己的本地内存，这样可以提高各个cpu的运行效率，避免对单一的内存忙等 NUMA非一致性内存架构，参考了MPP的设计，但是允许cpu访问非本地的内存，也就是说cpu对内存的访问分为local access and remote access，访问时间是不一致的，远程访问的速度当然要慢些 缺点是在共享内存时维持高速缓存一致性的开销非常大，尤其时当多处理器快速连续的尝试访问相同的内存区时问题更突出，解决方法有：使用缓存一致性协议(MESIF，SCI)尽量减少需要维护缓存一致性的通信 所以，NUMA设计的重点是让处理器快速的访问在同一单元的内存]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>memory</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[术语解释]]></title>
    <url>%2F2017%2F05%2F19%2F%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[网络错误粘包 根源是网络传输的分包、组包 + 发送端、接收端的缓冲区存在 只存在于TCP流协议中，UDP传输不存在，因为，TCP会分、并包来提高效率，所以包之间没有消息保护边界 TCP异构的消息不存在这个问题，因为结构不同，接收端不会迷惑，同构（譬如同样结构的的一串字符串）时，由于发送端网络延时/接收端不能及时接受时，两串消息就可能在接收端完全混合在一起，导致无法识别]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>network</tag>
      </tags>
  </entry>
</search>