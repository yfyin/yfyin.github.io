<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ssh免密码登录和传输]]></title>
    <url>%2F2017%2F05%2F19%2Fssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%92%8C%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[Why玩linux的，都会遇到需要操作一大堆serve时，要切换不同身份，端口和密码去分别登录，烦人的很，其实ssh提供了一种基于非对称加密的方法实现免密码登录 How假定需要从A传输文件或登录到B，执行以下步骤 Step 1在A机器上生成的ssh public-private keys，如果已经生成过了，可忽略这一步1ssh-keygen -t rsa 就会在~/.ssh/目录下生成一个id_rsa (private key) and id_ras.pub (public key) Step 2在A机器上配置~/.ssh/config文件,add below content12345Host fire HostName 115.159.114.116 Port 22 User ubuntu IdentityFile ~/.ssh/id_rsa Note: ‘Port’ field default to 22, ‘User’ default to the current account name on machine A ‘IdentityFile’ is the private key you want to user on machine A, aka the private key file you generated in step 1 Please modify them if necessary Step 3在机器B上，添加机器A的public key的完成内容到 ~/.ssh/authorized_keys，create the file if not not exist可以添加多个哦 添加完成后，就可以在A上免密ssh到B了 ssh fire scp ./xxx fire:~/ ReferenceSimplify Your Life With an SSH Config File]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>tool</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang中对象方法作为函数指针]]></title>
    <url>%2F2017%2F05%2F19%2Fgolang%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[裸函数作为指针不是什么新鲜事，其它的语言也是可以的，golang当然也可以，譬如12345type FT func(int)func Fa(int)&#123;&#125;func Test(FT)&#123;&#125;Test(Fa) //pass function as parameter 但是像下面这样，对象实例的方法是否可以作为函数参数传递呢？12345678type A struct &#123; // ...&#125;func (a *A) Foo(bar, baz int) &#123;&#125;b := new(A)foob := b.Foo // foob is of type func(int, int) 答案是肯定的，而且很智能：当特定对象实例的method作为函数指针时传递时，接受者会保证在调用的时候，调用到是这个对象实例的method，method的任何操作都会针对该对象实例生效，而且不需要传任何类似于this、self指针之类的东西 换句话说，对象实例+method 作为绑定的整体传递给接受者的 通过以下代码可以验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( "fmt")type Outer struct&#123; a string&#125;func (o *Outer)Hello(in *Inner)&#123; fmt.Println("Inner:",in,"\tcall\tOuter:",o.a)&#125;type Inner struct&#123; a string cb Cb&#125;type Cb func(*Inner)func (in *Inner)Register(cb Cb)&#123; in.cb = cb&#125;func (in *Inner)Say()&#123; in.cb(in)&#125;func main() &#123; out1 := Outer&#123;a:"out1 instance"&#125; out2 := Outer&#123;a:"out2 instance"&#125; fmt.Println("out1 :",&amp;out1) fmt.Println("out2 :",&amp;out2) in1 := Inner&#123;a:"int1 instance"&#125; in1.Register(out1.Hello) in1.Say() in1.Register(out2.Hello) in1.Say() &#125; 执行起来输出如下结果1234out1 : &amp;&#123;out1 instance&#125;out2 : &amp;&#123;out2 instance&#125;Inner: &amp;&#123;int1 instance 0xc6be0&#125; call Outer: out1 instanceInner: &amp;&#123;int1 instance 0xc6be0&#125; call Outer: out2 instance 参考文章https://groups.google.com/forum/#!topic/golang-nuts/t1r6px7yGIYhttps://github.com/golang/go/issues/2280]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>golang</tag>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存架构]]></title>
    <url>%2F2017%2F05%2F19%2F%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Basic knowlege of memory arch why to solve the mismatch of cpu and memory speed, avoid cpu hungry to decrease the frequency memory access from cpu, and access cpu cache if that have to happen do every effort to avoid missing hit of cpu cache whatSMP（UMA）一致性内存架构，早期的架构，多个CPU共享使用一块物理内存，总线硬件负责协调各CPU对内存的访问，所以对各个CPU来说，看到的内存数据是一致的，所以才叫做Uniform Memory Access MPP针对SMP share one memory的缺点，设计分布式存储器模式，every cpu have their own individual memory, called a node, all the node are full connected as one system, the consistency among nodes is guaranted by software not hardware(bus)。每个CPU只能访问自己的本地内存，这样可以提高各个cpu的运行效率，避免对单一的内存忙等 NUMA非一致性内存架构，参考了MPP的设计，但是允许cpu访问非本地的内存，也就是说cpu对内存的访问分为local access and remote access，访问时间是不一致的，远程访问的速度当然要慢些 缺点是在共享内存时维持高速缓存一致性的开销非常大，尤其时当多处理器快速连续的尝试访问相同的内存区时问题更突出，解决方法有：使用缓存一致性协议(MESIF，SCI)尽量减少需要维护缓存一致性的通信 所以，NUMA设计的重点是让处理器快速的访问在同一单元的内存]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>memory</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[术语解释]]></title>
    <url>%2F2017%2F05%2F19%2F%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[网络错误粘包 根源是网络传输的分包、组包 + 发送端、接收端的缓冲区存在 只存在于TCP流协议中，UDP传输不存在，因为，TCP会分、并包来提高效率，所以包之间没有消息保护边界 TCP异构的消息不存在这个问题，因为结构不同，接收端不会迷惑，同构（譬如同样结构的的一串字符串）时，由于发送端网络延时/接收端不能及时接受时，两串消息就可能在接收端完全混合在一起，导致无法识别]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>network</tag>
      </tags>
  </entry>
</search>